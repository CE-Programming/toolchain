	.assume	adl=1

;-------------------------------------------------------------------------------

	.section	.text

	.global	__fppop1
	.type	__fppop1, @function
	.global	__fppop2
	.type	__fppop2, @function

__fppop1:
	ld	bc, 0800000h
__fppop2:
	sla	e
	jr	z, .denormal
	add	hl, bc
	ret	nc
	add	hl, bc
.denormal:
	inc	e
	ret

;-------------------------------------------------------------------------------

	.section	.text

	.global	__fppack
	.type	__fppack, @function
	.global	__fppack.normalize
	.type	__fppack.normalize, @function
	.global	__fppack.normalized
	.type	__fppack.normalized, @function

__fppack.normalize:
	dec	b
	call	nz, __fppack.normalize.entry
__fppack:
	add	hl, de
	jr	nc, __fppack.normalize
__fppack.normalized:
	rrc	l
	rlc	l
	adc	a, 07Fh
	adc	hl, de
	ld	a, b
	adc	a, e
	srl	c
	rra
	srl	b
	ret	c
	add	hl, de
	ret

__fppack.normalize.entry:
	add	a, a
	adc	hl, hl
	ret	m
	jr	nz, .normalize.continue
	or	a, a
	jr	nz, .normalize.continue
	ld	b, 1
.normalize.loop:
	add	a, a
	adc	hl, hl
	ret	m
.normalize.continue:
	djnz	.normalize.loop
	add	hl, de
	ret

;-------------------------------------------------------------------------------

	.section	.text

	.global	__fppack2
	.type	__fppack2, @function
	.global	__fppack2.normalize
	.type	__fppack2.normalize, @function
	.global	__fppack2.normalized
	.type	__fppack2.normalized, @function

__fppack2.normalize:
	dec	b
	call	nz, __fppack2.normalize.loop
__fppack2:
	add	hl, de
	jr	nc, __fppack2.normalize
__fppack2.normalized:
	ld	a, b
	add	ix, de
	jr	nc, .rounded
	dec	ix
	add	ix, de
	jr	nc, .round
	bit	0, l
	jr	z, .rounded
.round:
	scf
	adc	hl, de
	adc	a, e
.clear:
	add	hl, de
	jr	nc, .clear
.rounded:
	cp	a, 0FFh
	jr	z, .infinite
	sla	c
	rra
	ret	nc
	add	hl, de
	ret
.infinite:
	sla	c
	rra
	ex	de, hl
	ret

__fppack2.normalize.loop:
	add	ix, ix
	adc	hl, hl
	ret	m
	djnz	__fppack2.normalize.loop
	add	hl, de
	ret

;-------------------------------------------------------------------------------
