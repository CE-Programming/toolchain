#include "crt.h"

	.assume	adl = 1

	.equ	ti.mpTmr1Counter, 0x0F20000
	.equ	ti.mpTmrCtrl, 0x0F20030

	.equ	ti.bTmr1Enable, 0
	.equ	ti.bTmr1Crystal, 1
	.equ	ti.bTmr1Overflow, 2
	.equ	ti.bTmr1CountUp, 9

	.equ	ti.Arc_Unarc, 0x021448
	.equ	ti.usb_ResetTimer, 0x00004F0
	.equ	ti.usb_DisableTimer, 0x00004F4
	.equ	ti.HomeUp, 0x020828
	.equ	ti.DrawStatusBar, 0x021A3C
	.equ	ti.ChkFindSym, 0x02050C
	.equ	ti.Mov9ToOP1, 0x020320
	.equ	ti.PutS, 0x0207C0
	.equ	ti.ChkInRam, 0x021F98
	.equ	ti.OP1, 0xD005F8
	.equ	ti.OP3, 0xD0060E
	.equ	ti.AppVarObj, 0x15
	.equ	ti.ClrScrn, 0x020814
	.equ	ti.NewLine, 0x0207F0
	.equ	ti.GetKey, 0x020D8C
	.equ	ti.flags, 0xD00080
	.equ	ti.RunIndicOff, 0x020848
	.equ	ti.PushRealO1, 0x020614
	.equ	ti.Mov8b, 0x020304
	.equ	ti.AnsName, 0x020FF4
	.equ	ti.FindSym, 0x020510
	.equ	ti.StrngObj, 4
	.equ	ti.Get_Tok_Strng, 0x020870
	.equ	ti.Isa2ByteTok, 0x0204AC
	.equ	ti.PopRealO1, 0x0205DC
	.equ	ti.MovFrOP1, 0x02032C
	.equ	ti.ClrLCDFull, 0x020808

	.section	.header,"ax",@progbits

	.local	__header
__header:
#if HAS_APPLICATION
	.db	0x00					; 0x00 is signifier for C applications (also force includes icon/description)
#else
	.db	0xEF, 0x7B, 0x00		; 0x00 is signifier for C programs
#endif

	.section	.init,"ax",@progbits

#if HAS_APPLICATION
	.equ	ti.onSP, 0xD007FA
	.equ	ti.ResetStacks, 0x02103C
	.equ	ti.asm_prgm_size, 0xD0118C
	.equ	ti.JForceCmd, 0x020164
	.equ	ti.kClear, 0x09
	.equ	ti.DelMem, 0x020590
	.equ	ti.userMem, 0xD1A881
	.equ	ti.pixelShadow, 0xD031F6
	.equ	ti.textShadow, 0xD006C0
	.equ	ti.cmdShadow, 0xD0232D
	.equ	ti.MemClear, 0x0210DC
	.equ	ti.ClrTxtShd, 0x020818

	.global	__start
__start:
	ld	iy, ti.flags
	ld	sp, (ti.onSP)			; reset stacks
	call	ti.ResetStacks
	ld	bc, ___data_len
	or	a, a
	sbc	hl, hl
	adc	hl, bc
	jr	z, .L.skip_data_copy
	ld	hl, ___data_lma
	ld	de, ___data_vma
	ldir
.L.skip_data_copy:
	call	___app_start
	ld	de, (ti.asm_prgm_size)
	ld	hl, ti.userMem
	call	ti.DelMem
	or	a, a
	sbc	hl, hl
	ld	(ti.asm_prgm_size), hl
	ld	hl, ti.pixelShadow
	ld	bc, 8400 * 3
	call	ti.MemClear
	call	ti.ClrTxtShd
	ld	hl, ti.textShadow
	ld	de, ti.cmdShadow
	ld	bc, $104
	ldir
	ld	a, ti.kClear
	jp	ti.JForceCmd
	.local	___app_start
___app_start:
#else
	.global	__start
__start:
	ld	iy, ti.flags
#endif

#if HAS_RUN_PRGM
	ld	de, ___prgm_caller
	call	ti.MovFrOP1			; ti.MovFROP1
	pop	hl
	ld	de, 1
	add	hl, de
	dec	hl
	jr	nc, .L.no_rerun
	ld	hl, .L.rerun_handler
	ld	(__start._main), hl
	pop	hl
	ld	(.L.rerun_handler.retval), hl
	pop	hl
	ld	(.L.rerun_handler.callback), hl
	pop	hl
	ld	(.L.rerun_handler.data_size), hl
	ex	de, hl
	add	hl, sp				; user callback data
	dec	hl
	ld	(.L.rerun_handler.data), hl
	db	0x3E				; ld a, push hl
.L.no_rerun:
	push	hl				; push hl
#endif

#if HAS_LIBLOAD
	call	ti.PushRealO1			; save running program name
	jr	.L.tryfind
.L.inram:
	call	ti.Arc_Unarc
.L.tryfind:
	ld	hl, __libloadname - 1
	call	ti.Mov9ToOP1
	ld	a, ti.AppVarObj
	ld	(ti.OP1), a
	call	ti.ChkFindSym
	jr	c, .L.notfound
	call	ti.ChkInRam
	jr	z, .L.inram			; if in ram, archive libload and search again
	ld	hl, 9 + 1 + __libloadnamelen + 2
	add	hl, de
	push	hl
	call	ti.PopRealO1			; restore running program name
	pop	hl				; start of loader (required to be in hl)
	ld	de, ___libload_libs		; start of relocation data
	jp	(hl)				; jump to the loader -- it should take care of everything else
.L.notfound:
	call	ti.PopRealO1			; restore running program name
	call	ti.ClrScrn
	call	ti.HomeUp
	ld	hl, __missingappvar
	call	ti.PutS
	call	ti.NewLine
	ld	hl, __webaddress
	call	ti.PutS
	jp	ti.GetKey

#if !HAS_APPLICATION
___libload_libs:
	LIBLOAD_LIBS				; autogenerated by cedev-obj
	nop
#else
___libload_libs_ret:
#endif
#endif

	call	ti.RunIndicOff			; assumes iy = flags
	call	ti.usb_DisableTimer
	di

.L.bss_zeroize:
	ld	hl, ___bss_len
	ld	bc, 0
	xor	a, a
	sbc	hl, bc
	jr	z, .L.bss_done
	ld	de, ___bss_low
	push	de
	ld	(de), a
	dec	hl
	sbc	hl, bc
	pop	hl
	jr	z, .L.bss_done
	ld	bc, ___bss_len
	dec	bc
	inc	de
	ldir
.L.bss_done:

	res	1, (iy + 0x0D)			; no text buffer
	res	3, (iy + 0x4A)			; use first shadow buffer
	set	5, (iy + 0x4C)			; only display
	ld	hl, 0xE00305
	ld	a, (hl)
	ld	(_exit.flash_wait_states), a
	ld	(hl), h				; set flash wait states to 3; 1 was definitely
						; too low, 2 is untested
	ld	(_exit.sp), sp			; save sp for exiting

#if HAS_MAIN_ARGC_ARGV
	.equ	.L.argstemp, 0xD120D6		; saveSScreen + 14007
	call	ti.PushRealO1
	ld	de, .L.argstemp
	ld	a, e				; Lenter
	ld	(de), a
	inc	de
	ld	hl, ti.OP1 + 1
	call	ti.Mov8b
	ld	a, d				; Lspace
	ld	(de), a
	inc	de
	push	de
	call	ti.AnsName
	call	ti.FindSym
	ex	de, hl
	pop	de
	xor	a, ti.StrngObj
	jr	nz, .L.parse_ans_done
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	jr	.L.parse_ans_next
.L.parse_ans_loop:
	inc	hl
	dec	bc
	push	hl
	push	bc
	push	de
	call	ti.Get_Tok_Strng
	pop	de
	ld	hl, ti.OP3
	ldir
	pop	bc
	pop	hl
	bit	2, d
	jr	nz, .L.parse_ans_done
	ld	a, (hl)
	call	ti.Isa2ByteTok
	jr	nz, .L.parse_ans_next
	inc	hl
	dec	bc
.L.parse_ans_next:
	ld	a, c
	or	a, b
	jr	nz, .L.parse_ans_loop
.L.parse_ans_done:
	ld	bc, 0
	ld	hl, .L.argstemp
	sbc	hl, de
	add	hl, sp
	ld	sp, hl
	ld	hl, (_exit.sp)
	push	bc
	db	0x3E				; ld a, push hl
.L.argv_loop:
	push	hl
	inc	bc
.L.skip_spaces_loop:
	dec	de
	ld	a, (de)
	cp	a, 0x20				; Lspace
	jr	z, .L.skip_spaces_loop
	dec	hl
	ld	(hl), 0
.L.arg_copy_loop:
	dec	hl
	ld	(hl), a
	dec	de
	ld	a, (de)
	cp	a, 0x20				; Lspace
	jr	z, .L.argv_loop
	cp	a, 0xD6				; Lenter
	jr	nz, .L.arg_copy_loop
	push	hl
	sbc	hl, hl
	add	hl, sp
	push	hl
	push	bc
	call	ti.PopRealO1
#endif

#if HAS_CLOCK
	ld	hl, ti.mpTmrCtrl + 1
	set	ti.bTmr1CountUp - 8, (hl)
	dec	hl
	res	ti.bTmr1Enable, (hl)
	set	ti.bTmr1Crystal, (hl)
	res	ti.bTmr1Overflow, (hl)
	ld	l, (ti.mpTmr1Counter + 1) & 0xFF
	ld	de, 0				; Set the counter to zero
	ld	(hl), de
	dec	hl
	ld	(hl), e
	ld	l, ti.mpTmrCtrl & 0xFF
	set	ti.bTmr1Enable, (hl)		; Enable the timer
#endif

#if HAS_INIT_ARRAY
	ld	hl, __init_array_start
	jr	.L.init_array_start
.L.init_array_loop:
	push	hl
	ld	hl, (hl)
	call	__indcallhl
	pop	hl
	inc	hl
	inc	hl
	inc	hl
.L.init_array_start:
	ld	de, __init_array_end
	or	a, a
	sbc	hl, de
	add	hl, de
	jr	nz, .L.init_array_loop

	.extern	__init_array_start
	.extern	__init_array_end
#endif

#if HAS_MAIN_ARGC_ARGV
	call	___main_argc_argv
#else
	call	_main
#endif
	.equ	__start._main, $ - 3
	.global	___exithl
___exithl:
#if HAS_ATEXIT || HAS_FINI_ARRAY || HAS_ABORT
	push	hl
	push	de
#endif
	.global	_exit
	.type	_exit, @function
_exit:
#if HAS_ATEXIT
	jr	.L.exit_function_start
.L.exit_function_loop:
	ld	hl, (ix + 1 + 0 * 3)
	ld	(__atexit_functions), hl
	pop	hl
	ld	de, (ix + 1 + 2 * 3)
	push	hl
	push	de
	push	hl
	ld	hl, (ix + 1 + 1 * 3)
	push	hl
	pea	ix + 1
	call	_free
	pop	bc
	pop	hl
	call	__indcallhl
	pop	bc
	pop	bc
.L.exit_function_start:
	ld	ix, (__atexit_functions)
	ld	bc, -1
	add	ix, bc
	jr	c, .L.exit_function_loop
#endif
#if HAS_FINI_ARRAY
	ld	hl, __fini_array_end
	jr	.L.fini_array_start
.L.fini_array_loop:
	dec	hl
	dec	hl
	dec	hl
	push	hl
	ld	hl, (hl)
	call	__indcallhl
	pop	hl
.L.fini_array_start:
	ld	de, __fini_array_start
	or	a, a
	sbc	hl, de
	add	hl, de
	jr	nz, .L.fini_array_loop

	.extern	__fini_array_start
	.extern	__fini_array_end
#endif
#if HAS_ATEXIT || HAS_FINI_ARRAY || HAS_ABORT
	pop	de
	pop	hl
#endif
#if HAS_ABORT
	jr	.L.skip._abort
	.global	_abort
	.type	_abort, @function
_abort:
	ld	hl, 6				; SIGABRT
.L.skip._abort:
#endif
#if HAS_APPLICATION
	ld	sp, (_exit.sp)
#else
	ld	sp, 0
	.global	_exit.sp
	.equ	_exit.sp, $ - 3
#endif
	push	hl
	ld	iy, ti.flags
#if HAS_APPLICATION
	ld	a, (_exit.flash_wait_states)
#else
	ld	a, 0
	.local	_exit.flash_wait_states
	.equ	_exit.flash_wait_states, $ - 1
#endif
	ld	(0xE00305), a
	call	ti.usb_ResetTimer
	ld	a, 1
	ld	(0xF00008), a			; clear on interrupt
	res	4, (iy + 0x09)			; onInterrupt,(iy+onFlags)
	set	0, (iy + 0x03)			; graphDraw,(iy+graphFlags)
	set	1, (iy + 0x0D)			; use text buffer
	res	3, (iy + 0x4A)			; use first shadow buffer
	res	5, (iy + 0x4C)			; use shadow buffer
	call	ti.ClrLCDFull
	call	ti.HomeUp
	call	ti.DrawStatusBar
	pop	hl				; hl = exit code
	ret

#if HAS_RUN_PRGM
.L.rerun_handler:
	ld	hl, (_exit.sp)
	ld	de, 0
	.equ	.L.rerun_handler.data_size, $ - 3
	add	hl, de
	ld	(_exit.sp), hl			; move exit.sp to real ret
	ld	hl, 0
	.equ	.L.rerun_handler.retval, $ - 3
	ex	(sp), hl
	ld	de, 0
	.equ	.L.rerun_handler.data, $ - 3
	push	de
	push	hl
	jp	0
	.equ	.L.rerun_handler.callback, $ - 3
#endif

#if HAS_LIBLOAD
	.section	.rodata.libload
__missingappvar:
	.db	"Need "
__libloadname:
	.db	"LibLoad"
	.equ	__libloadnamelen, $ - __libloadname
	.db	0
__webaddress:
	.db	"http://tiny.cc/clibs",0
#endif

#if HAS_APPLICATION
	.section	.bss
	.global	_exit.sp
_exit.sp:
	.d24	0
_exit.flash_wait_states:
	.db	0

#if HAS_LIBLOAD
	.section	.data
___libload_libs:
	LIBLOAD_LIBS				; autogenerated by cedev-obj
	nop
	jp	___libload_libs_ret
#endif
#endif

#if HAS_MAIN_ARGC_ARGV
	.extern	___main_argc_argv
#else
	.extern	_main
#endif
