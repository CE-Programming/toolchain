	.assume	adl=1

	.section	.text

	.global	__fpdiv
	.type	__fpdiv, @function

; IEEE single precision division
; aubc = aubc / euhl
__fpdiv: ; CHECK: same(bitcast(float, pair8_24_t, { out.BC, out.A }), bitcast(float, pair8_24_t, { in.BC, in.A }) / bitcast(float, pair8_24_t, { in.HL, in.E })) && out.DE == in.DE && out.HL == in.HL && out.IX == in.IX && out.IY == in.IY
	push	de
	push	hl
	xor	a, e
	push	af
	xor	a, e
	push	bc
	call	__fppop1
	ex	(sp), hl
	ld	d, e
	ld	e, a
	call	__fppop2
	inc	e
	jr	z, .nonfinite.1
	ld	a, d
	inc	a
	jr	z, .nonfinite.2
	add	a, 080h
	dec	d
	jr	nz, .exponent.adjust
	ex	(sp), hl
	add	hl, bc
	jr	c, .normalize.divisor.done
	sbc	hl, bc
	jr	z, .divisor.zero
.normalize.divisor.loop:
	dec	a
	add	hl, hl
	add	hl, bc
	jr	nc, .normalize.divisor.loop
.normalize.divisor.done:
	add	hl, bc
	ex	(sp), hl
.exponent.adjust:
	ex	de, hl	; ude=UHL, uhl=UDE
	ld	h, b
	rl	b
	ld	c, a
	sbc	hl, bc
	ld	b, h
	ld	c, l
	pop	hl
	add	hl, de	; uhl=UHL+UDE
	ex	de, hl	; ude=UHL+UDE, uhl=UHL
	xor	a, a
	sbc	hl, de	; uhl=-UDE
	ex	de, hl	; ude=-UDE, uhl=UHL+UDE
	add	hl, de	; uhl=UHL
.normalize.dividend.loop:
	add	hl, de
	jr	c, .normalize.dividend.done
	sbc	hl, de
	jr	z, .dividend.zero
	dec	bc
	add	hl, hl
	jr	nc, .normalize.dividend.loop
	add	hl, de
.normalize.dividend.done:
	cp	a, b
	jr	nc, .return.overflow
	dec	bc
	dec	bc
	ld	a, c
	inc	b
	ld	bc, 0800000h | (23 << 8)
	jr	z, .divide.entry.normal
	adc	a, b
	ld	b, a
	ld	a, c
	jr	nc, .return.underflow
	push	iy
	ld	iy, 0
	jr	nz, .divide.entry.subnormal
	dec	hl
	add	hl, de
	jr	.subsubnormal

.divisor.zero:
	pop	de
	sbc	hl, de
	jr	nz, .return.nonfinite
.return.nan:
	inc	b
.return.overflow:
	ld	c, b
.return.nonfinite:
	pop	af
	pop	hl
	pop	de
	or	a, 07Fh
	ret

.nonfinite.1:
	inc	d
	pop	de
	jr	z, .return.nan
	push	hl
	pop	bc
	jr	.return.nonfinite

.nonfinite.2:
	pop	hl
	dec	hl
	add	hl, bc
	jr	c, .return.nan
.return.underflow:
	sbc	hl, hl
.dividend.zero:
	pop	de
	jr	.return

.divide.entry.normal:
	push	iy
	ld	iyl, b
.divide.loop:
	add	iy, iy
	add	hl, hl
	jr	c, .divide.overflow
	add	hl, de
	jr	c, .divide.setbit
	sbc	hl, de
	djnz	.divide.loop
	add	hl, hl
	jr	.divide.finish
.divide.overflow:
	add	hl, de
.divide.setbit:
.divide.entry.subnormal:
	inc	iy
	djnz	.divide.loop
	add	hl, hl
	inc	hl
.divide.finish:
	jr	c, .round
	dec	de
	add	hl, de
.round:
	ccf
.subsubnormal:
	lea	de, iy + 0
	pop	iy
	sbc	hl, hl
	inc	hl
	add	hl, de
	pop	de
	ld	e, a
	adc	a, 1
	srl	e
	jr	nc, .return
	add	hl, bc
.return:
	sla	d
	rra
	ex	(sp), hl
	pop	bc
	pop	de
	ret

	.extern	__fppop1
	.extern	__fppop2
