; Performs 48 bit ("short long long") bit shift left
; 
; Arguments:
; ude = Most significant bytes of arg 1
; uhl = Least significant bytes of arg 1
; ubc = Amount to shift by (effectively just shift by c)


; Returns:
; ude:uhl = ude:uhl<<c

assume	adl=1

	section	.text
	public	__sllshl
__sllshl:
	push iy
	push de
	push hl
	pop iy ; iy will be used for least significant, hl for most going forward
	pop hl

	bit	0, c
	jr	z, .bit0
	add	iy, iy
	adc hl, hl
.bit0:
	bit	1, c
	jr	z, .bit1
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
.bit1:
	bit	2, c
	jr	z, .bit2
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
.bit2:
	bit	3, c
	jr	z, .bit3
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
.bit3:
	bit 4, c
	jr z, .bit4
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
	add	iy, iy
	adc hl, hl
.bit4:
	bit 5, c
	jr z, .finish

	; Shift least significant 8 left
	add	iy, iy
	add	iy, iy
	add	iy, iy
	add	iy, iy
	add	iy, iy
	add	iy, iy
	add	iy, iy
	add	iy, iy
	
	; Move least significant to most signficant
	push iy
	pop hl
	ld iy, 0

	; put final most significant bytes into de and fix iy
.finish:
	push iy
	push hl
	pop de
	pop hl
	pop iy
	ret