	assume	adl=1

	section	.text
	public	_strlcpy

; BSD variant of strncpy that ensures the destination is null-terminated.
; OpenBSD reference: https://github.com/openbsd/src/blob/master/lib/libc/string/strlcpy.c
; size_t strlcpy(char *dst, const char *src, size_t dsize)

_strlcpy:

	ld iy, 0
	lea bc, iy ; set bc to 0
	add iy, sp

	; do min(strlen(src), dsize-1)

	; strlen(src)
	ld hl, (iy + 6) ; hl = pointer to src
	xor a, a ; clear carry and set a to 0
	cpir ; dec bc until byte at (hl) matches a (= NUL)
	; calculate HL=-BC-1
	sbc hl, hl
	scf
	sbc hl, bc ; always sets carry flag
	; now hl = strlen(src)

	push hl ; save this for after dsize check

	ld bc, (iy + 9) ; bc = dsize
	ex de, hl ; de = strlen(src)

	; check if dsize is zero
	sbc hl, hl ; set hl to -1, carry was already set
	add hl, bc ; hl = -1 + dsize
	jr nc, .strlcpy_done ; do nothing if dsize is zero

	; dsize is not zero, compare them
	; hl = dsize - 1
	; de = strlen(src)

	; carry flag is set, so calculate hl - (de + 1)
	sbc hl, de

	; if hl <= de, (dsize - 1) <= strlen(src); keep bc as dsize
	jr c, .ready_for_ldir

	; hl > de, so (dsize - 1) > strlen(src); set bc to strlen(src) + 1
	push de
	pop bc
	inc bc

.ready_for_ldir:
	ld de, (iy + 3) ; put dst in de
	ld hl, (iy + 6) ; put src in hl
	; bc is filled already and greater than 0

	; at this point we are set up for an ldir:
	; hl has the start address
	; de has the destination address
	; bc has the length (including space for null terminator)
	ldir

	; replace final byte with NUL, in case src null terminator wasn't reached
	dec de
	; a is already 0
	ld (de), a ; store null terminator at the address pointed to by de

.strlcpy_done:
	; return strlen(src)

	pop hl ; get the result of strlen(src) from earlier and put into hl

	ret
