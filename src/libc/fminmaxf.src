	.assume	adl=1

; fminf and fmaxf treat signed zeros as -0.0f < +0.0f.
;
; The same result will be returned no matter the order of the arguments unless
; both arguments are NaN.
;
; If both values are NaN, a NaN value will be returned. However, it is
; unspecified whether the first, second, or a different NaN is returned.

;-------------------------------------------------------------------------------

	.section	.text

	.global	_fminf
	.type	_fminf, @function
	.global	_fmin
	.type	_fmin, @function
	.global	_fmaxf
	.type	_fmaxf, @function
	.global	_fmax
	.type	_fmax, @function

_fminf:
_fmin:
	ld	iy, 0
	add	iy, sp
	ld	bc, $010000
	ld	de, (iy + 4)	; upper 24 bits of X
	ld	hl, (iy + 10)	; upper 24 bits of Y
	xor	a, a
	add	hl, hl	; Y
	adc	a, b
	ex	de, hl
	add	hl, hl	; X
	sbc	a, b
	; (X+, Y+): A =  0 NC  Z ; compare
	; (X-, Y-): A =  0 NC  Z ; invert compare
	; (X-, Y+): A = -1  C NZ ; X < Y
	; (X+, Y-): A = +1 NC NZ ; X > Y
	jr	nz, .L_fmin.different_sign
; .L_fmin.same_sign:
	sbc	hl, de		; X - Y
	add	hl, de
	jr	nz, .L_fmin.x_and_y_diff
	ld	a, (iy + 3)
	cp	a, (iy + 9)
.L_fmin.x_and_y_diff:
	sbc	a, a
	xor	a, (iy + 6)	; invert the comparison
	add	a, a
.L_fmin.different_sign:
	jr	c, _fminmaxf_common.no_swap
; .L_fmin.swap:
	ex	de, hl
	add	hl, bc		; overflows for NaN and Inf
	jr	c, _fminmaxf_common.y_maybe_NaN

;-------------------------------------------------------------------------------

	.section	.text

	.local	_fminmaxf_common.no_swap
	.local	_fminmaxf_common.y_maybe_NaN

_fminmaxf_common:
_fminmaxf_common.return_y:
	ld	hl, (iy + 9)
	ld	e, (iy + 12)
	ret

_fminmaxf_common.y_maybe_NaN:
	ld	a, l
	or	a, h
	or	a, (iy + 9)
	jr	z, _fminmaxf_common.return_y	; infinity
	; jr	.return_x

_fminmaxf_common.no_swap:
	add	hl, bc		; overflows for NaN and Inf
	jr	c, _fminmaxf_common.x_maybe_NaN
_fminmaxf_common.return_x:
	ld	hl, (iy + 3)
	ld	e, (iy + 6)
	ret

_fminmaxf_common.x_maybe_NaN:
	ld	a, l
	or	a, h
	or	a, (iy + 3)
	jr	z, _fminmaxf_common.return_x	; infinity
	jr	_fminmaxf_common.return_y

;-------------------------------------------------------------------------------

	.section	.text

	.global	_fmaxf
	.global	_fmax

_fmaxf:
_fmax:
	ld	iy, 0
	add	iy, sp
	ld	bc, $010000
	ld	de, (iy + 4)	; upper 24 bits of X
	ld	hl, (iy + 10)	; upper 24 bits of Y
	xor	a, a
	add	hl, hl	; Y
	adc	a, b
	ex	de, hl
	add	hl, hl	; X
	sbc	a, b
	; (X+, Y+): A =  0 NC  Z ; compare
	; (X-, Y-): A =  0 NC  Z ; invert compare
	; (X-, Y+): A = -1  C NZ ; X < Y
	; (X+, Y-): A = +1 NC NZ ; X > Y
	jr	nz, .L_fmax.different_sign
; .L_fmax.same_sign:
	sbc	hl, de		; X - Y
	add	hl, de
	jr	nz, .L_fmax.x_and_y_diff
	ld	a, (iy + 3)
	cp	a, (iy + 9)
.L_fmax.x_and_y_diff:
	sbc	a, a
	xor	a, (iy + 6)	; invert the comparison
	add	a, a
.L_fmax.different_sign:
	jr	nc, _fminmaxf_common.no_swap
; .L_fmax.swap:
	ex	de, hl
	add	hl, bc		; overflows for NaN and Inf
	jr	c, _fminmaxf_common.y_maybe_NaN
.L_fmax.return_y:
	ld	hl, (iy + 9)
	ld	e, (iy + 12)
	ret
