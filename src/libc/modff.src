	.assume	adl=1

	.section	.text
	.global	_modff
	.type	_modff, @function
	.global	_modf
	.type	_modf, @function

.ifdef PREFER_CE_LIBC

	.set	_modff, 0x0220EC
	.set	_modf, _modff

.else

; float modf(float x, float* iptr)
_modff:
_modf:
	call	__frameset0

	; copy the mantissa into HL and BC
	sbc	hl, hl
	ld	bc, (ix + 6) ; mantissa
	add	hl, bc
	adc	hl, hl
	ld	a, (ix + 9) ; exponent
	ld	e, a
	rla
	ld	d, a
	jr	z, .L.maybe_inf
	inc	a
	ld	a, e
	jr	z, .L.ret_nan
.L.not_inf:
	ld	a, d
	sub	a, 127	; |x| < 1.0f
	jr	c, .L.less_than_one
	; fintie and normal
	ld	hl, (ix + 6) ; mantissa
	; E has exponent
	push	de
	push	hl
	call	_truncf
	pop	af
	pop	af

	ld	a, e
	ex	de, hl
	ld	hl, (ix + 12)	; float *iptr
	ld	(hl), de
	inc	hl
	inc	hl
	inc	hl
	ld	(hl), a
	ex	de, hl
	ld	e, a
	ld	bc, (ix + 6)
	ld	a, (ix + 9)

	call	__fsub
	push	bc
	pop	hl
	ld	e, a
	pop	ix
	ret

.L.maybe_inf:
	inc	a
	jr	nz, .L.not_inf
	ld	a, e
	ld	hl, (ix + 12)	; float *iptr
	ld	(hl), bc
	inc	hl
	inc	hl
	inc	hl
	ld	(hl), a	; inf exp
	xor	a, a
	ld	e, a
	sbc	hl, hl
	pop	ix
	ret

.L.less_than_one:
	ld	bc, 0
	ld	a, e
	and	a, $80
	; A:UBC = copysignf(0.0f, x)
.L.ret_nan:
	ld	hl, (ix + 12)	; float *iptr
	ld	(hl), bc
	inc	hl
	inc	hl
	inc	hl
	ld	(hl), a
	ld	hl, (ix + 6)	; mantissa
	; E has exponent
	pop	ix
	ret

	.extern	__frameset0
	.extern	_truncf
	.extern	__fsub

.endif
