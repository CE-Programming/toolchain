	.assume	adl=1

;-------------------------------------------------------------------------------

	.section	.text

	.global	_strtoll
	.type	_strtoll, @function
	.global	_strtoimax
	.type	_strtoimax, @function

_strtoimax:
_strtoll:
	call	__strtoll_common
	; overflow if Carry is set
	jr	c, _strtoll.out_of_range
	ld	a, b
	rla
	jr	c, _strtoll.maybe_out_of_range
	ret	nz
	jp	__llneg

_strtoll.maybe_out_of_range:
	; greater than INT_MAX
	jr	nz, _strtoll.overflow
	; negative
	; check that the result is not an exact INT_MIN
	ld	b, a		; B = (B << 1)
	call	__llcmpzero
	set	7, b
	ret	z		; exact INT_MIN
_strtoll.underflow:
	xor	a, a		; set Z
_strtoll.out_of_range:
_strtoll.overflow:
	ld	b, $80
	ld	hl, 5		; ERANGE
	ld	c, h
	ld	(_errno), hl
	ld	l, h		; ld hl, 0
	push	hl
	pop	de
	; BC:UDE:UHL = LLONG_MIN
	ret	z		; underflow
	; overflow
	dec	hl
	dec	de
	dec	bc
	; BC:UDE:UHL = LLONG_MAX
	ret

;-------------------------------------------------------------------------------

	.section	.text

	.global	_strtoull
	.type	_strtoull, @function
	.global	_strtoumax
	.type	_strtoumax, @function

_strtoumax:
_strtoull:
	call	__strtoll_common
	; overflow if Carry is set
	jr	c, _strtoull.out_of_range
	ret	nz
	jp	__llneg

_strtoull.out_of_range:
	ld	hl, 5		; ERANGE
	ld	(_errno), hl
	ld	l, h		; ld hl, 0
	dec	hl
	push	hl
	pop	de
	ld	b, l
	ld	c, l
	; BC:UDE:UHL = ULLONG_MAX
	ret

;-------------------------------------------------------------------------------

	.section	.text

	.local	__strtoll_common

__strtoll_common.invalid_base:
	xor	a, a
	ld	c, a
	; Setting C (base) to zero ensures that cp a, c will never set carry.
	; forcing the function to return.
	push	af
	; sets BC:UDE:UHL to zero
	jr	__strtoll_common.invalid_base_hijack

__strtoll_common:
	; output: BC:UDE:UHL
	; NC = no overflow for strtoull
	; C = overflow, raise ERANGE
	; Z means that A is zero = negate return value
	; NZ means that A is non-zero = positive return value
	push	ix
	ld	ix, 0
	lea	hl, ix - 37	; ld hl, -37
	add	ix, sp

	ld	bc, (ix + 15)	; base
	add	hl, bc
	jr	c, __strtoll_common.invalid_base
	; UBC is zero here
	ld	hl, (ix + 9)	; nptr
;-------------------------------------------------------------------------------
; consume whitespace (inlinsed isspace)
__strtoll_common.whitespace_loop:
	ld	a, (hl)
	inc	hl
	cp	a, 32
	jr	z, __strtoll_common.whitespace_loop
	sub	a, 9
	add	a, -5
	jr	nc, __strtoll_common.whitespace_loop
; test for plus/minus signs
	; A = (HL - 1) - 9 + -5
	; A = (HL - 1) - 14
	xor	a, '-' - 14
	push	af
	jr	z, __strtoll_common.minus_sign
	xor	a, ('+' - 14) ^ ('-' - 14)
	jr	z, __strtoll_common.plus_sign
	dec	hl
	xor	a, a
__strtoll_common.plus_sign:
__strtoll_common.minus_sign:
	; A = 0, (HL) = start of number
;-------------------------------------------------------------------------------
; update the base if needed
	or	a, c		; base
	jr	z, __strtoll_common.auto_base
	xor	a, 16
	jr	z, __strtoll_common.hex_base
	xor	a, 2 ^ 16
	jr	nz, __strtoll_common.other_base
__strtoll_common.auto_base:	; test for 0* 0x* 0X* 0b* 0B*
__strtoll_common.bin_base:	; test for 0x* 0X*
__strtoll_common.hex_base:	; test for 0b* 0B*
	inc	c
	ld	a, (hl)
	xor	a, '0'
	jr	nz, __strtoll_common.maybe_decimal
	inc	hl
	ld	a, (hl)
	res	5, a		; upper case
	xor	a, 'X'
	jr	z, __strtoll_common.maybe_hex
	xor	a, 'B' ^ 'X'
	jr	z, __strtoll_common.maybe_bin
	dec	hl
	dec	c
	jr	nz, __strtoll_common.other_base
	ld	c, 8		; octal
	jr	__strtoll_common.save_new_base

__strtoll_common.maybe_bin:
	bit	4, c
	jr	nz, __strtoll_common.undo_inc	; hexadecimal
	; base is 0 or 2
	inc	hl
	ld	c, 2
	jr	__strtoll_common.save_new_base

__strtoll_common.maybe_hex:
	bit	1, c
	jr	nz, __strtoll_common.undo_inc	; binary
	; base is 0 or 16
	inc	hl
	ld	c, 16
	jr	__strtoll_common.save_new_base

__strtoll_common.undo_inc:
	dec	hl
	; dec	c
	; jr	__strtoll_common.other_base
__strtoll_common.maybe_decimal:
	; set to decimal if base is not zero
	dec	c
	jr	nz, __strtoll_common.other_base
	ld	c, 10		; decimal
__strtoll_common.save_new_base:
;-------------------------------------------------------------------------------
__strtoll_common.other_base:
	ld	a, (hl)		; first digit of the number
	push	hl
	pop	iy
__strtoll_common.invalid_base_hijack:
	; or	a, a		; carry is cleared here
	sbc	hl, hl
	; A = first digit of the number
	; HL = 0
	; B = 0
	; C = base
	; (ix - 2) = (first-non-whitespace) XOR '-'
	; 6, (ix - 3) = Z if result should be negative, NZ for positive
	; 0, (ix - 3) = overflow bit

	; The strto* functions return nptr (not nptr + whitespace) if there are
	; no digits in the string. Having a digit check here allows us to
	; directly handle the case where the string has no digits.

	sub	a, 48
	cp	a, 10
	jr	c, __strtoll_common.check_digit
	; Convert an alphabetic digit, case-insensitive
	sub	a, 65 - 48
	res	5, a
	add	a, 10
__strtoll_common.check_digit:
	; End the loop when the digit is out of range for the base
	cp	a, c
	push	hl	; (ix - 6) = $000000
	push	hl	; (ix - 9) = $000000
	jr	c, __strtoll_common.loop
;-------------------------------------------------------------------------------
; no digit found or invalid base
	; set *endptr to nptr and return 0
	ld	iy, (ix + 9)	; nptr
	jr	__strtoll_common.write_endptr

;-------------------------------------------------------------------------------
; CC per non-decimal digit:
; no overflow : 109F + 10R +  9W + 33
; overflow    : 117F + 11R + 10W + 35
__strtoll_common.check_decimal:
	cp	a, c
	jr	nc, __strtoll_common.end_loop
__strtoll_common.loop:
__strtoll_common.__llmul_add_b_overflow:
; value = (value * C) + A
; bit 0, (ix - 3) is set if overflow has occured
	; (ix - 6) --> HL
	; (ix - 9) --> DE
	; HL --> BC
	push	hl		; (ix - 12)
	ld	h, c
	ld	l, (ix - 6)	; L
	mlt	hl

	; (255 * 255) + 255 < 65535 so no 16bit carry can occur
	add	a, l
	ld	(ix - 6), a	; L
	ld	d, c
	ld	e, (ix - 5)	; H
	mlt	de
	ld	l, h
	ld	h, b		; B is guaranteed to be zero if overflow has not occured
	adc	hl, de		; handles carry from adding A
	xor	a, a

	ld	(ix - 5), l	; H
	ld	d, c
	ld	e, (ix - 4)	; UHL
	mlt	de
	ld	l, h
	ld	h, a
	add	hl, de
	ld	(ix - 4), l	; UHL
	ld	d, c
	ld	e, (ix - 9)	; E
	mlt	de
	ld	l, h
	ld	h, a
	add	hl, de
	ld	(ix - 9), l	; E
	ld	d, c
	ld	e, (ix - 8)	; D
	mlt	de
	ld	l, h
	ld	h, a
	add	hl, de
	ld	(ix - 8), l	; D
	ld	d, c
	ld	e, (ix - 7)	; UDE
	mlt	de
	ld	l, h
	ld	h, a
	add	hl, de
	ld	(ix - 7), l	; UDE

	pop	de
	ld	l, h
	ld	b, d
	ld	d, c		; D = base
	mlt	bc
	ld	h, c
	ld	c, d		; C = base
	mlt	de

	add.s	hl, de
	sbc	a, b		; set carry if B is non-zero or if there was carry previously
	jr	c, __strtoll_common.set_overflow_bit
__strtoll_common.next_digit:
	; (ix - 6) --> HL
	; (ix - 9) --> DE
	; HL --> BC
	; C = base
	; IY = str
	; 0, (ix - 3) = overflow bit
	inc	iy
	; Convert a numerical digit
	ld	a, (iy)
	sub	a, 48
	cp	a, 10
	jr	c, __strtoll_common.check_decimal
	; Convert an alphabetic digit, case-insensitive
	sub	a, 65 - 48
	res	5, a
	add	a, 10
	; End the loop when the digit is out of range for the base
	cp	a, c
	jr	c, __strtoll_common.loop
__strtoll_common.end_loop:
;-------------------------------------------------------------------------------
__strtoll_common.write_endptr:
	ld	c, l
	ld	b, h
	ld	hl, (ix + 12)	; endptr
	add	hl, de
	or	a, a
	sbc	hl, de
	jr	z, __strtoll_common.endptr_null
	ld	(hl), iy
__strtoll_common.endptr_null:
	pop	de
	pop	hl
	pop	af		; overflow and sign flags
	pop	ix
	ret

;-------------------------------------------------------------------------------
__strtoll_common.set_overflow_bit:
	set	0, (ix - 3)	; set carry
	jr	__strtoll_common.next_digit

;-------------------------------------------------------------------------------

	.extern	_errno
	.extern	__llneg
	.extern	__llcmpzero
