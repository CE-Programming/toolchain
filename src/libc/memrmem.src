	.assume	adl=1

	.section	.text

	.global	_memrmem
	.type	_memrmem, @function

; void *memrmem(const void *haystack, size_t haystack_len, const void *needle, size_t needle_len)
	.equ	haystack, 3
	.equ	haystack_len, 6
	.equ	needle, 9
	.equ	needle_len, 12
_memrmem:
	ld	iy, 0
	add	iy, sp
	ld	hl, (iy + haystack_len)
	ld	bc, (iy + needle_len)
	sbc	hl, bc
	jr	c, .L.ret_null	; (haystack_len < needle_len)
	; (haystack_len >= needle_len)

	push	hl
	adc	hl, bc
	ex	de, hl
	; DE = needle_len

	; move to the end of the needle
	ld	hl, (iy + needle)
	; return haystack when haystack_len is zero (implies that needle_len is also zero)
	jr	z, .L.zero_haystack_len
	add	hl, bc
	dec	hl
	ld	(iy + needle), hl

	sbc	hl, hl
	adc	hl, bc
	pop	bc
	ld	hl, (iy + haystack)

	; move to the end of the haystack
	add	hl, de
	dec	hl

	ret	z		; return (haystack + haystack_len - 1) if needle_len is zero

	inc	bc
	; BC = (haystack_len - needle_len + 1) = search_len
	; haystack_len >= needle_len && needle_len != 0, therefore haystack_len >= 1
	call	.L.begin_loop
	jr	nz, .L.ret_null
	; test for a match at the last possible position
	call	_memrcmp_fast
	inc	hl
	ret	z
.L.ret_null:
	or	a, a
	sbc	hl, hl
	ret

.L.loop:
	pop	hl
	pop	bc
.L.begin_loop:
	ld	de, (iy + needle)
	ld	a, (de)
	cpdr			; search for the start of the string
	ret	po		; end of search_len
	push	bc
	push	hl
	call	_memrcmp_fast
	jr	nz, .L.loop
	inc	hl
	ld	sp, iy
	ret

.L.zero_haystack_len:
	pop	hl
	ld	hl, (iy + haystack)
	ret

_memrcmp_fast:
	; Input:
	; HL = haystack + needle_len - 1
	; DE = needle + needle_len - 1
	; A = (DE)
	; Output:
	; Z = match
	; NZ = no match
	inc	hl
	ld	bc, (iy + needle_len)
.L_memrcmp_fast.loop:
	cpd
	ret	po
	dec	de
	ld	a, (de)
	jr	z, .L_memrcmp_fast.loop
	ret
