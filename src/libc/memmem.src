	.assume	adl=1

	.section	.text

	.global	_memmem
	.type	_memmem, @function
	.local	_memcmp_fast
	.type	_memcmp_fast, @function

; void *memmem(const void *haystack, size_t haystack_len, const void *needle, size_t needle_len)
	.equ	haystack, 3
	.equ	haystack_len, 6
	.equ	needle, 9
	.equ	needle_len, 12
_memmem:
	ld	iy, 0
	add	iy, sp
	ld	hl, (iy + haystack_len)
	ld	bc, (iy + needle_len)
	sbc	hl, bc
	jr	c, .L.ret_null	; (haystack_len < needle_len)
	; (haystack_len >= needle_len)

	push	hl
	scf
	sbc	hl, hl
	add	hl, bc
	pop	bc
	ld	hl, (iy + haystack)
	ret	nc		; return haystack if needle_len is zero
	inc	bc
	; BC = (haystack_len - needle_len + 1) = search_len
	; haystack_len >= needle_len && needle_len != 0, therefore haystack_len >= 1
	call	.L.begin_loop
	jr	nz, .L.ret_null
	; test for a match at the last possible position
	dec	hl
	push	hl
	call	_memcmp_fast
	pop	hl
	ret	z
.L.ret_null:
	or	a, a
	sbc	hl, hl
	ret

.L.loop:
	pop	bc
.L.begin_loop:
	ld	de, (iy + needle)
	ld	a, (de)
	cpir			; search for the start of the string
	ret	po		; end of search_len
	push	bc
	push	hl
	dec	hl
	call	_memcmp_fast
	pop	hl
	jr	nz, .L.loop
	; pop	bc
	ld	sp, iy
	dec	hl
	ret

_memcmp_fast:
	; Input:
	; HL = haystack
	; DE = needle
	; A = (DE)
	; Output:
	; Z = match
	; NZ = no match
	ld	bc, (iy + needle_len)
.L_memcmp_fast.loop:
	cpi
	ret	po
	inc	de
	ld	a, (de)
	jr	z, .L_memcmp_fast.loop
	ret
