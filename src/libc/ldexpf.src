	assume	adl=1

	section	.text
	public	_ldexpf
	public	_ldexp
	; when FLT_RADIX == 2, scalbn is equivilent to ldexp
	public	_scalbnf
	public	_scalbn

if PREFER_OS_LIBC

_ldexpf := 0220DCh
_ldexp := _ldexpf
_scalbnf := _ldexpf
_scalbn := _ldexpf

else

; (set to 0 or 1) avoid returning negative zero on underflow with Ti's floats
__ldexpf_avoid_negative_zero := 1

; ldexpf behaviour:
; - signed zero, infinity, and NaN inputs are returned unmodified
; - ERRNO and FE_INEXACT are set if a finite value becomes zero or infinite
; - FE_INEXACT is set if rounding occured
;-------------------------------------------------------------------------------

	private	__ldexpf_helper
__ldexpf_helper:
.maybe_subnormal:
	; A = zero, carry = signbit
	rra	; restore signbit and clear carry
	adc	hl, bc	; BC is zero
.ret_self:
	ld	hl, (iy + 3)	; mant
	ret	z	; return zero/inf/NaN
	dec	bc	; BC is now -1
; .subnormal_input:
	; BC is -1 here
	bit	7, (iy + 11)	; scale sign
	ld	de, (iy + 9)	; scale
	jr	nz, _ldexpf.move_subnormal_down
; .move_subnormal_up:
.norm_loop:
	add	hl, hl
	jr	c, .normalized
	ex	de, hl
	add	hl, bc	; --scale
	ex	de, hl
	jr	c, .norm_loop
; .still_subnormal:
	; DE is -1 here
	; saves 8F for this path at a cost of 3 bytes:
if 0
	inc	de	; ld e, 0
	jr	_ldexpf.finish_subnormal
end if
.normalized:
	inc	de	; don't touch the Z flag
	ex	de, hl
	; Z is set here
	jr	_ldexpf.scale_up_subnormal

;-------------------------------------------------------------------------------
; When the input and output are normal:
; scaling up  : 60F + 12R + 4W + 2
; scaling down: 60F + 12R + 4W + 4
_scalbn:
_scalbnf:
_ldexp:
_ldexpf:
	ld	iy, 0
	lea	bc, iy + 0
	add	iy, sp
	ld	hl, (iy + 3)	; mant
	add	hl, hl
	ld	a, (iy + 6)	; expon
	ld	e, a		; signbit
	adc	a, a
	jr	z, __ldexpf_helper.maybe_subnormal
	ld	c, a
	inc	a
	jr	z, __ldexpf_helper.ret_self	; inf NaN
	ld	a, e		; signbit
	ld	de, (iy + 9)	; scale
	ex	de, hl
	add	hl, bc	; add expon
	bit	7, (iy + 11)	; scale sign
	jr	nz, .scale_down
.scale_up:
	; HL is [1, $8000FD]
	ld	c, b	; ld bc, 0
	dec	bc	; ld bc, -1
.scale_up_subnormal:	; <-- HL is [0, $7FFFFE]
	inc	c	; ld bc, $FFFF00
	inc	c	; ld bc, $FFFF01 ; BC is -255 ; sets NZ
	; ld	bc, -255
	add	hl, bc
	jr	c, .overflow_to_inf
	; sbc	hl, bc	; restore hl
	dec	l	; we only care about the low 8 bits
	ex	de, hl
.finish_subnormal:
	push	hl
.finish:
	rla	; extract signbit
	rr	e
	rr	(iy - 1)
	pop	hl
	rr	h
	rr	l
	ret

;-------------------------------------------------------------------------------

.move_subnormal_down:
	; DE = scale
	; BC is -1 here
	; first we need to test that the result won't be zero
	call	__ictlz
	ex	de, hl	; HL = scale
	; A is [1, 23]
	; return zero if (scale < clz_result - 24) or (clz_result - 25 >= scale)
	add	a, -24	; A is [-23, -1] and carry is cleared
	ld	c, a	; sign extend A
	ld	a, l
	sbc	hl, bc
	cpl
	jr	nc, _ldexpf.shru_common
; .underflow:
	inc	b	; ld b, 0 ; sets Z
.underflow_to_zero:	; <-- Z is set when underflowing to zero
.overflow_to_inf:	; <-- NZ is set when infinite
.raise_erange_avoid_negative_zero:
	ld	hl, $800000
	jr	nz, .overflow
	add	hl, hl	; ld hl, 0
if __ldexpf_avoid_negative_zero
	; prevents negative zero from being emitted on underflow
	res	7, (iy + 6)
end if
.overflow:
	ex	de, hl
.raise_erange:
	ld	hl, 5	; ERANGE
	ld	(_errno), hl
.raise_inexact:
	ld	hl, ___fe_cur_env
	set	5, (hl)	; FE_INEXACT
.result_is_exact:
	ld	a, (iy + 6)	; expon
	rla	; extract signbit
	ex	de, hl
	; B is $FF if infinite and $00 otherwise
	rr	b
	ld	e, b
	ret

;-------------------------------------------------------------------------------
.scale_down:
	push	de	; mant <<= 1
	ld	e, l	; shift amount
	; HL is not INT_MIN here
	dec	hl
	add	hl, hl
	jr	nc, .finish	; expon > 0
;-------------------------------------------------------------------------------
.shru_to_subnormal:
	; Z is set here
	xor	a, a
	ld	c, 48	; ld bc, 24 << 1
	add	hl, bc
	pop	hl	; reset SP
	jr	nc, .underflow_to_zero
	sub	a, e
	set	7, (iy + 5)	; set implicit mantissa bit
.shru_common:
	; A should be [0, 23]
	ld	b, a
	ld	hl, (iy + 3)	; mantissa
	push	hl	; ld (iy - 3), hl
	xor	a, a
	inc	b
	; shift amount will be [1, 24]
	ld	d, a	; ld d, 0
	ld	c, (iy - 1)
.shru_loop:
	adc	a, d	; collect sticky bits
	srl	c
	rr	h
	rr	l
	djnz	.shru_loop
	ld	(iy - 1), c
	pop	de
	ld	d, h
	ld	e, l

	; round upwards to even if (round && (guard || sticky))
	jr	nc, .no_round
	; we must ensure that FE_INEXACT is raised since rounding has occured
	or	a, a
	jr	nz, .round_up
	inc	a	; ld a, 1
	and	a, e	; test guard bit
	jr	z, .no_round_inexact
.round_up:
	inc	de	; round upwards to even (wont overflow)
.no_round:
	adc	a, a	; test the sticky and round bits
	jr	z, .result_is_exact
	; carry wont be set
.no_round_inexact:
	; we need to raise ERANGE if the mantissa was rounded down to zero
	ld	a, c	; UDE
	or	a, d
	or	a, e
	jr	nz, .raise_inexact
	; NZ needs to be set here
if __ldexpf_avoid_negative_zero
	jr	.raise_erange_avoid_negative_zero
else
	jr	.raise_erange
end if

	extern	_errno
	extern	___fe_cur_env
	extern	__ictlz

end if
