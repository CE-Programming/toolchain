	.assume	adl=1

	.section	.text

	.global	_strlcat

_strlcat:
	ld	iy, 0
	lea	bc, iy + 0
	add	iy, sp
	ld	hl, (iy + 6)	; src
	xor	a, a
	cpir
	sbc	hl, hl
	dec	hl
	sbc	hl, bc
	; carry is clear
	ex	de, hl

	; inlined strnlen
	ld	bc, (iy + 9)	; max_size
	sbc	hl, hl
	sbc	hl, bc
	; Allows dst to be NULL when max_size is zero
	jr	z, _strlcat.zero_size	; return src_len
	add	hl, bc
	push	de		; src_len
	ld	de, (iy + 3)	; dst
	sbc	hl, de
	ex	de, hl
	cpir
	add	hl, de
	jr	z, _strlcat.finish_strnlen
	inc	hl
_strlcat.finish_strnlen:

	ex	de, hl
	ld	hl, (iy + 9)	; max_size
	; (copy_size + 1) = max_size - dst_len
	xor	a, a
	sbc	hl, de
	jr	z, _strlcat.no_room

	pop	bc		; src_len
	push	bc

	; (copy_size + 1) - src_len - 1
	scf
	sbc	hl, bc

	jr	c, _strlcat.copy_size_lt_src_len
	; (copy_size + 1 - 1) >= src_len
	; copy_size >= src_len
	sbc	hl, hl
_strlcat.copy_size_lt_src_len:
	xor	a, a
	adc	hl, bc
	jr	z, _strlcat.zero_copy_size
	push	hl
	pop	bc

	push	de		; dst_len
	ld	hl, (iy + 3)	; dst
	add	hl, de		; dst + dst_len
	ex	de, hl
	ld	hl, (iy + 6)	; src
	ldir
	ld	(de), a		; null terminate
	pop	de		; dst_len
_strlcat.zero_copy_size:
_strlcat.no_room:
	pop	hl		; src_len
_strlcat.zero_size:
	; return src_len + dst_len
	add	hl, de
	ret
