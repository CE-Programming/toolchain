	.assume	adl=1

	.section	.text

	.global	_scalblnf
	.type	_scalblnf, @function
	.global	_scalbln
	.type	_scalbln, @function

; float _scalblnf(float, long)
_scalbln:
_scalblnf:
	; We need to cast the int32_t scale to int24_t via saturation.
	; scalblnf will always overflow/underflow if the scale is larger than +-280.
	ld	hl, 12
	add	hl, sp
	ld	a, (hl)
	dec	hl
	; If bits [16, 23] match bits [24, 31] then we don't need to do anything.
	; It implies that the scale is either already [-65536, +65535] and can
	; be safely truncated, or that the original and truncated scale values
	; are both larger than +-65535 and have the same sign.
.L.overflow:
	cp	a, (hl)
	jp	z, _scalbnf
	; We need modify the scale value to ensure that overflow/underflow still occurs.
	; Ensure that bits[16, 23] are not all zeros/ones to set the scale to a large magnitude.
	or	a, $03
	dec	a
	; bit 23 = bit 31, bit 16 is cleared, and bit 17 is set
	ld	(hl), a	; store the new scale
	; cp a, a	; set Z flag
	jr	.L.overflow

	.extern	_scalbnf
