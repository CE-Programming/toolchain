	.assume	adl=1
	.section	.text
	.global	___sleep_common
	.type	___sleep_common, @function

___sleep_common:
; Timing assumes fetching from RAM (4cc) and the first timer read being valid.

; Calculate the end time.
	section	.text
	.global	___sleep_common.1
	.type	___sleep_common.1, @function
___sleep_common.1:
	scf				; cf = 1
					;    = correction
	.global	___sleep_common.2
	.type	___sleep_common.2, @function
___sleep_common.2:
	ld	a, e			; auhl = start or ticks
	.global	___sleep_common.3
	.type	___sleep_common.3, @function
___sleep_common.3:
	pop	de
	pop	bc			; eubc = ticks or start
	adc	hl, bc
	adc	a, e			; auhl = start + ticks + correction
					;      = end
; Prepare.
	ld	e, a			; euhl = end
	push	hl
	.db	0xFE			; cp a, $C5
.L.check:
	.db	0xC5			; push bc
; ^ don't care cc
; Get the current time.
	push	de
	call	_clock			; euhl = now, cf = 0
; ^ 42 + cc(_clock) cc
; Check if the end time has been reached.
	ld	a, e			; auhl = now
	pop	de
	pop	bc			; dubc = end
;	or	a, a
	sbc	hl, bc
	sbc	a, e			; auhl = now - end
; ^ 48 cc
; Check again if the end time has not been reached.
	jr	c, .L.check
; ^ 13 cc (conditional jr taken)
; 42 + 48 + 202 + 31 + 48 + 13 = 384 cc check
; Return 0 to indicate success.
	sbc	hl, hl
	ret
; ^ 24 cc

; 202 - 75 + 31 + 48 + 13 + 24 = 243 cc after end time captured


	extern	_clock
