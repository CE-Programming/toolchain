	.assume	adl=1

	.set	ti.kUp, 3
	.set	ti.kLeft, 2
	.set	ti.kDown, 4
	.set	ti.kEnter, 5
	.set	ti.kClear, 9
	.set	ti.kRight, 1
	.set	ti.kQuit, 0x40
	.set	ti.kIns, 0x0B
	.set	ti.curLock, 4
	.set	ti.flags, 0xD00080
	.set	ti.keyExtend, 0xD0058E
	.set	ti.curRow, 0xD00595
	.set	ti.curUnder, 0xD00599
	.set	ti.PutS, 0x207C0
	.set	ti.PutC, 0x207B8
	.set	ti.PutPS, 0x207C8
	.set	ti.GetKey, 0x20D8C
	.set	ti.CursorOn, 0x208B0
	.set	ti.CursorOff, 0x208A8
	.set	ti.PullDownChk, 0x208BC
	.set	ti.ConvKeyToTok, 0x20E40
	.set	ti.GetTokString, 0x20874
	.set	ti.PutTokString, 0x20D74
	.set	ti.ClrTxtShd, 0x20818

	.section	.text
	.global	_os_GetTokenInput
	.type	_os_GetTokenInput, @function

_os_GetTokenInput:
	call	__frameset0
	ld	iy, flags
	ld	l, (iy + $0D)
	ld	h, (iy + $4C)
	push	hl			; save text flags
	set	1, (iy + $0D)		; use text buffer
	res	5, (iy + $4C)		; use text buffer
	call	ti.ClrTxtShd
	ld	hl, (ix + 6)		; hl -> input string prompt
	add	hl, de
	xor	a, a
	sbc	hl, de
	call	nz, ti.PutS
	ld	hl, (ti.curRow)
.L.start:
	push	hl			; save initial row/column
	push	ix			; save frame pointer
	ld	hl, (ix + 9)
	push	hl			; save buf start pointer
	push	hl			; save buf pointer
	ld	hl, (ix + 12)		; buffer size
	push	hl			; save remaining size
.L.loop:
	call	ti.CursorOn
.L.getkey:
	call	ti.GetKey
	call	ti.CursorOff
	call	ti.PullDownChk
	push	af
	call	ti.CursorOn
	pop	af
	jr	c, .L.getkey
	cp	a, ti.kQuit
	jr	z, .L.done
	dec	a			; kRight=1
	cp	a, ti.kEnter-ti.kRight		; kEnter=kDown+1
	jr	c, .L.loop
	jr	z, .L.done
	inc	a
	cp	a, ti.kIns
	jr	z, .L.loop
	cp	a, ti.kClear
	jr	z, .L.clear
	cp	a, $F3			; for lists? idk something is wrong with _PullDownChk
	jr	c, .L.conv_key
	cp	a, $FB+1
	jr	nc, .L.conv_key
	sub	a, $7C
	ld	(ti.keyExtend), a
	ld	a, $FE
.L.conv_key:
	call	ti.ConvKeyToTok
	pop	bc			; restore remaining size
	xor	a, a
	cp	a, d			; check if 2-byte token
	sbc	hl, hl			; sets Z if 1-byte token
	dec	hl
	add	hl, bc			; subtract 1 or 2 from remaining size
	jr	nc, .L.full
	ex	(sp), hl			; restore buf pointer
	jr	z, .L.one_byte_token
	ld	(hl), d
	inc	hl
.L.one_byte_token:
	ld	(hl), e
	inc	hl
	ex	(sp), hl			; save buf pointer
	push	hl			; save remaining size
	call	ti.GetTokString
	call	ti.PutPS
	jr	.L.loop

.L.done:
	pop	de			; remaining size
.L.done_full:
	call	ti.ClrTxtShd
	call	ti.CursorOff
	pop	hl			; restore buf pointer
	pop	de			; restore buf start pointer
	or	a, a
	sbc	hl, de
	pop	de			; frame pointer
	pop	de			; initial row/column
	pop	de			; restore text flags
	ld	(iy + $0D), e
	ld	(iy + $4C), d
	pop	ix
	ret

.L.full:
	call	ti.GetKey
	cp	a, ti.kEnter
	jr	z, .L.done_full
	cp	a, ti.kClear
	jr	nz, .L.full
.L.clear:
	pop	hl			; buf pointer
	pop	hl			; buf start pointer
	pop	ix			; restore frame pointer
	pop	de			; restore initial row/column
	ld	hl, ti.curRow
	ld	bc, (hl)
	ld	(hl), de
.L.clear_loop:
	push	hl
	ld	hl, (hl)
	ld	a, ' '
	call	ti.PutC
	or	a, a
	sbc	hl, bc			; check the row/column before the print
	pop	hl
	jr	nz, .L.clear_loop
	ld	(hl), de
	ex	de, hl
	jp	.L.start

	extern	__frameset0
